[["index.html", "LAB analysis Descripción Aviso Legal: Protección de Propiedad Intelectual.", " LAB analysis Descripción Este bookdown contiene pasos y detalles a considerar en el análisis de genomas de bacterias acidolácticas (LAB) de Microbioma - Lab. Página web: https://microbioma-lab.com/inicio/ O escríbenos a: contacto@microbioma-lab.com Aviso Legal: Protección de Propiedad Intelectual. El material contenido en este manual está protegido por las leyes mexicanas de Propiedad Intelectual. Por lo que su reproducción o distribución no autorizada con fines de lucro está prohibida. "],["workflow-y-herramientas-en-general.html", "TEMA 1 : Workflow y herramientas en general 1.1 Otras herramientas:", " TEMA 1 : Workflow y herramientas en general Dependiendo del objetivo y alcance del estudio es el flujo de trabajo a seguirse. Si se quiere comparar con otras cepas relacionadas o no. 1.1 Otras herramientas: Además del flujo de trabajo ilustrado anteriormente, se pueden realizar otros análisis como: 1.1.1 Anotación funcional Prokka Propósito: Anotación rápida de genes, ARN y características genómicas. Entrada: Archivo genómico en FASTA. Salida: Archivos GFF, GBK, FAA (proteínas) y FFN (genes). Referencia: Prokka web page RAST Propósito: Anotación de ORFs en subsistemas funcionales. Entrada: Archivo genómico en FASTA. Salida: GenBank anotado (.gbk), tablas de funciones y subsistemas. Referencia: RAST server eggNOG-mapper v5.0.2 Propósito: Asignar COGs ortológicos y términos GO. Entrada: Secuencias proteicas (FAA) de Prokka o RAST. Salida: Tablas TSV con anotaciones ortológicas y GO. Referencia: Huerta-Cepas et al. (2019) eggNOG-mapper 1.1.2 Análisis funcional y rutas metabólicas dbCAN (Run_dbcan v3) Propósito: Identificar enzimas CAZymes. Entrada: Secuencias proteicas en FASTA. Salida: Informe TSV de familias CAZy. Referencia: Zheng et al. (2023) dbCAN BlastKOALA Propósito: Asignar proteínas a rutas KEGG. Entrada: Secuencias proteicas. Salida: Listado de KO (K numbers) y rutas. Referencia: Kanehisa et al. (2016) BlastKOALA iPath3.0 (KEGG) Propósito: Visualizar redes metabólicas. Entrada: Listado de módulos KEGG. Salida: Mapa interactivo SVG/HTML. Referencia: Darzi et al. (2018) iPath3.0 1.1.3 Identificación de genes de resistencia y virulencia ResFinder 3.2 Propósito: Detectar genes de resistencia antimicrobiana. Entrada: Genoma o contigs en FASTA. Salida: Tabla de genes con cobertura e identidad. Referencia: Zankari et al. (2012) ResFinder Abricate Propósito: Cribado de genes específicos en bases de datos especializadas. RGs (Resistance Genes): Genes asociados con resistencia antimicrobiana adquirida. VGs (Virulence Genes): Genes que codifican factores de virulencia y patogenicidad. MGEs (Mobile Genetic Elements): Elementos genéticos móviles (plásmidos, transposones, integrones). Entrada: Secuencias genómicas en FASTA. Salida: Tablas TSV con coincidencias. Referencia: Seemann (2018) Abricate 1.1.4 Detección de elementos móviles y defensa bacteriana CRISPRCasFinder Propósito: Identificar arrays CRISPR y cas. Entrada: Genoma en FASTA. Salida: GFF con coordenadas y tipo de sistema. Referencia: Couvin et al. (2018) CRISPRCasFinder PHASTER Propósito: Detectar profagos integrados. Entrada: Genoma en FASTA/GBK. Salida: Tabla de regiones prophage. Referencia: Arndt et al. (2016) PHASTER 1.1.5 Localización de elementos genómicos especiales Island Viewer 4 Propósito: Detectar islas genómicas y genes de patogenicidad. Entrada: FASTA genómico. Salida: Track GFF/JSON de islas. Referencia: Bertelli et al. (2017) Island Viewer 4 antiSMASH Propósito: Identificar BGCs. Entrada: FASTA. Salida: GBK anotados, JSON de BGCs y gráficos. Referencia: Blin et al. (2021) antiSMASH BAGEL 4.0 Propósito: Encontrar bacteriocinas. Entrada: Secuencias proteicas/genoma. Salida: Informe HTML/TSV. Referencia: van Heel et al. (2018) BAGEL BiG-SLiCE &amp; BiG-FAM Propósito: Análisis a gran escala de BGCs para identificar familias y diversidad funcional. Entrada: Colección de archivos GenBank o JSON de BGCs (p. ej., salidas de antiSMASH). Salida: Agrupación de BGCs en familias (BiG-FAM) y mapas de similitud BGC (BiG-SLiCE). Referencia: Kautsar et al. (2021) BiG-SLiCE, Kautsar et al. (2021) BiG-FAM CORASON &amp; evoMining Propósito: Análisis comparativo y evolutivo de BGCs; identificación de genes accesorios y rutas evolutivas. Entrada: Secuencias de BGCs anotadas (GenBank/JSON). Salida: Árbol filogenético de BGCs (CORASON) y perfiles de evolución de dominios enzimáticos (evoMining). Referencia: Navarro-Muñoz et al. (2020) CORASON, Cruz-Morales et al. (2016) evoMining Propósito: Encontrar bacteriocinas. Entrada: Secuencias proteicas/genoma. Salida: Informe HTML/TSV. Referencia: van Heel et al. (2018) BAGEL 1.1.6 Análisis comparativo de pangenoma y contenido proteico Roary Propósito: Calcular core-genome y pangenoma. Entrada: GFF de múltiples genomas. Salida: gene_presence_absence.csv, árbol Newick. Referencia: Page et al. (2015) Roary OrthoVenn Propósito: Clustering de ortólogos y Venn. Entrada: FASTA de proteínas. Salida: Diagramas de Venn y tablas de clústeres. Referencia: Wang et al. (2015) OrthoVenn 1.1.7 Construcción de filogenias MUSCLE Propósito: Alineación múltiple de secuencias. Entrada: FASTA proteico. Salida: Archivo de alineación. Referencia: Edgar (2004) MUSCLE RaxML Propósito: Árbol filogenético con bootstrap. Entrada: Alineación. Salida: Newick y soporte. Referencia: Stamatakis (2014) RAxML SplitTree4 Propósito: Árbol UPGMA de distancias. Entrada: Matriz de distancias. Salida: Diagrama UPGMA. Referencia: Huson y Bryant (2006) SplitTree4 1.1.8 Visualización y reporte final Scoary + GoFigure! Propósito: Enriquecimiento GO y visualización. Entrada: gene_presence_absence.csv y anotaciones GO. Salida: Tablas de enriquecimiento y gráficos. Referencia: Brynildsrud et al. (2016) Scoary, GoFigure! (2018). CGView Visualiza: GBK de RAST y antiSMASH. Salida: Imagen circular PNG/SVG. Referencia: Grant y Stothard (2008) CGView Proksee Visualiza: Archivos .gb de RAST. Salida: Mapa circular interactivo. Referencia: Proksee BV-BRC Visualiza: Genoma y pangenoma; usa Mash/MinHash y PGFams. Salida: Reporte HTML/PDF y árbol interactivo. Referencia: BV-BRC "],["control-de-calidad.html", "TEMA 2 : Control de calidad 2.1 fastp 2.2 fastqc 2.3 MultiQC", " TEMA 2 : Control de calidad Algunos pasos deben realizarse antes de poder usar las secuencias crudas recibidas: Remoción de adaptadores (Illumina, Nextera, etc). Filtrado de secuencias de baja calidad. Inspección de la calidad de secuencias. Para realizar esto, seguiremos los siguientes pasos: 2.1 fastp $ conda create --yes -n qc fastp fastqc multiqc $ conda activate qc $ fastp --detect_adapter_for_pe --overrepresentation_analysis --correction --cut_right --thread 2 --html trimmed/anc.fastp.html --json trimmed/anc.fastp.json -i data/anc_R1.fastq.gz -I data/anc_R2.fastq.gz -o trimmed/anc_R1.fastq.gz -O trimmed/anc_R2.fastq.gz -detect_adapter_for_pe: Especifica que estamos usando paired-end data. –overrepresentation_analysis: Analiza las secuencas sobre-representadas. –correction: tratará de corregir las bases basadas en un análisis de overlap de reads1 y reads2. –cut_right: usará el recorte el scan de recorte de calidad desde el inicio al final. –thread: Specify how many concurrent threads the process can use. –html and –json: Especificamos la ubicación de archivo de stats. -i data/anc_R1.fastq.gz -I data/anc_R2.fastq.gz: Especifica los dos archivos de entrada. -o trimmed/anc_R1.fastq.gz -O trimmed/anc_R2.fastq.gz: SpEspecifica los dos archivos de salida. 2.2 fastqc Correr fastq para checar secuencias (esto puede hacerse antes y después): fastqc -o RESULT-DIR INPUT-FILE.fq(.gz) ... 2.3 MultiQC MultiQC compila los resultados de FastQC y fastp en una página web clara y consolidada, permitiendo contextualizar múltiples muestras fácilmente a partir de los directorios de salida. multiqc DIRECTORY DIRECTORY ... "],["ensamble-de-genoma.html", "TEMA 3 : Ensamble de genoma", " TEMA 3 : Ensamble de genoma Luego de haber filtrado los genomas y revisado la calidad de las secuencias crudas, lo siguiente es hacer el ensamble. $ conda create -n assembly spades quast $ conda activate assembly $ spades.py -o result-directory -1 read1.fastq.gz -2 read2.fastq.gz Después de obtenido el ensamble debe analizarse la calidad del ensamble con quast. $ quast -o assembly/quast assembly/spades-default/scaffolds.fasta assembly/spades-150/scaffolds.fasta N50: longitud para la cual la suma de todos los contigs de esa longitud o mayor cubre al menos el 50% del ensamblaje. NG50: similar a N50, pero considerando la longitud del genoma de referencia en lugar del ensamblaje. NA50 y NGA50: similares a N50 y NG50, pero considerando bloques alineados en lugar de contigs. Miss-assemblies: contigs mal ensamblados o bases no alineadas. Genes y operones cubiertos: cantidad de genes y operones presentes en el ensamblaje en comparación con el genoma de referencia. "],["mapeo-contra-genoma-de-referencia.html", "TEMA 4 : Mapeo contra genoma de referencia", " TEMA 4 : Mapeo contra genoma de referencia Este paso es opcional y depende de qué es lo que se quiere comparar o el objetivo del estudio a realizar. Si queremos identificar los cambios ocurridos con la cepa mejorada. Hay dos enfoques posibles: Ensamblar un segundo genoma y compararlo con el genoma ancestral. Mapear las lecturas del mejorado directamente contra el genoma ensamblado del ancestral y luego identificar las variantes. La primera opción no es recomendable porque: Es computacionalmente más costosa y consume más recursos. No proporciona una medida clara de la certeza de los cambios detectados. Por eso, se opta por el segundo enfoque, conocido como llamado de variantes (variant calling). En este proceso, se utilizan las lecturas de Illumina del mejorado previamente filtradas con fastp y se mapean contra el genoma de referencia usando BWA. Luego, se identifican las mutaciones para evaluar los cambios evolutivos. $ conda create --yes -n mapping samtools bwa qualimap r-base $ conda activate mapping # bwa index help $ bwa index # indexing $ bwa index path/to/reference-genome.fa # bwa mem help $ bwa mem # single-end mapping, general command structure, adjust to your case $ bwa mem path/to/reference-genome.fa path/to/reads.fq.gz &gt; path/to/aln-se.sam # paired-end mapping, general command structure, adjust to your case $ bwa mem path/to/reference-genome.fa path/to/read1.fq.gz path/to/read2.fq.gz &gt; path/to/aln-pe.sam $ samtools sort -n -O sam mappings/evol1.sam | samtools fixmate -m -O bam - mappings/evol1.fixmate.bam $ rm mappings/evol1.sam # convert to bam file and sort $ samtools sort -O bam -o mappings/evol1.sorted.bam mappings/evol1.fixmate.bam # Once it successfully finished, delete the fixmate file to save space $ rm mappings/evol1.fixmate.bam $ samtools markdup -r -S mappings/evol1.sorted.bam mappings/evol1.sorted.dedup.bam # if it worked, delete the original file $ rm mappings/evol1.sorted.bam $ samtools flagstat mappings/evol1.sorted.dedup.bam $ samtools depth mappings/evol1.sorted.dedup.bam | gzip &gt; mappings/evol1.depth.txt.gz $ zcat mappings/evol1.depth.txt.gz | egrep &#39;^NODE_20_&#39; | gzip &gt; mappings/NODE_20.depth.txt.gz #stats $ qualimap bamqc -bam mappings/evol1.sorted.dedup.bam # Once finsished open reult page with $ firefox mappings/evol1.sorted.dedup_stats/qualimapReport.html $ samtools view -h -b -q 20 mappings/evol1.sorted.dedup.bam &gt; mappings/evol1.sorted.dedup.q20.bam "],["identificación-taxonómica.html", "TEMA 5 : Identificación taxonómica", " TEMA 5 : Identificación taxonómica $ conda create --yes -n kraken kraken2 bracken $ conda activate kraken $ kraken2 --use-names --threads 4 --db PATH_TO_DB_DIR --report example.report.txt example.fa &gt; example.kraken $ kraken2 --use-names --threads 4 --db minikraken2_v2_8GB_201904_UPDATE --fastq-input --report evol1 --gzip-compressed --paired ../mappings/evol1.sorted.unmapped.R1.fastq.gz ../mappings/evol1.sorted.unmapped.R2.fastq.gz &gt; evol1.kraken $ bracken -d PATH_TO_DB_DIR -i kraken2.report -o bracken.species.txt -l S "],["anotación-funcional-y-filogenia.html", "TEMA 6 : Anotación funcional y filogenia 6.1 PROKKA 6.2 Filogenia", " TEMA 6 : Anotación funcional y filogenia 6.1 PROKKA $ conda create --yes -n prokka prokka $ conda activate prokka $ prokka --kingdom Bacteria --genus GENUS --species SPECIE --outdir annotation assembly/scaffolds.fasta 6.2 Filogenia $ conda create -n phylo blast mafft raxml iqtree bedtools # Figure out the chromosome and location of the `gnd` gene # there *must* be a better way to do this grep -B 1 ‘NODE_\\|gnd’ ../annotation/*gbk # open a file to put the coordinates into using vi or nano vi gnd.bed # these are the coordinates from the contigs-file (Yours might be different), we copy into the vi/nano buffer NODE_42_length_35862_cov_7.082632 625 2031 # safe the file and exit vi/nano bedtools getfasta -fi ../assembly/contigs.fasta -bed gnd.bed &gt; gnd.fasta #finding orthologs blastn -db nt -query gnd.fasta -remote -evalue 1e-100 -outfmt &quot;6 qseqid sseqid sseq&quot; &gt; gnd_blast_hits.out awk &#39;BEGIN { OFS = &quot;\\n&quot; } { print &quot;&gt;&quot;$2, $3 }&#39; gnd_blast_hits.out &gt; gnd_blast_hits.fasta cat gnd.fasta &gt;&gt; gnd_blast_hits.fasta #alignment $ mafft gnd_blast_hits.fasta &gt; gnd_blast_hits.aln #building phylogeny $ raxmlHPC -s gnd_blast_hits.aln -m GTRGAMMA -n ecoli_tree -p 12345 iqtree -s gnd_blast_hits.aln "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
